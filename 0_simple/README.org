* 分子動力学法の実装
まずは最も素朴にMDを実装してみる。

** プログラムで使う変数
このプログラムでは、速度ベルレ法で系の時間発展を追跡する。
[[https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet][アルゴリズムを見る]]と、
- 粒子の位置 $x(t)$
- 粒子の速度 $v(t)$
- 粒子のかかる力（加速度） $a(t)$
- 時間刻み $\Delta t$
の4つの変数が現れることが分かる。

このプログラム中ではそれぞれ、
- 粒子の位置 ~conf[N][deg]~
- 粒子の速度 ~velo[N][deg]~
- 粒子のかかる力（加速度） ~force[N][deg]~
- 時間刻み ~dt~
という変数を用いることにしよう。もちろん、 ~N~ は系の粒子数、 ~deg~ は空間次元である。

表紙で説明したように、周期境界条件を用いるので、シミュレーションの箱の大きさ $L$ も使う必要が出てくる。そのために、変数 ~Lbox~ を導入している。

今回は手抜きをして、これらの変数をグローバル変数で宣言している。
C++を使っているのだからクラスを作って管理すべきかもしれないが、本稿の主眼はMDの説明であるから、お目溢し願います。

** シミュレーション全体の構成
メイン関数はシンプルで、実質的には4行のみである。
1. 正方格子状に粒子を配置する
2. A粒子とB粒子の初期位置をランダムに混ぜる
3. 初期速度をマクスウェル・ボルツマン分布で与える
4. NVEシミュレーションを実行

それぞれ見て行こう。

** 各変数の初期化
まず第一のステップでは、変数 ~conf~ に初期位置を格納していく。
ここでは正方格子状に粒子を配置しているが、MDの練習では初期位置は何でも構わない。

なお、2成分LJモデルを考えているので、MDの中では粒子 $i$ がA粒子かB粒子かを判定する必要がある。
このプログラムでは、この判別を粒子インデックスを使って行っている。グローバル変数で宣言した
#+begin_src C++
constexpr auto N_A = N*4/5;
#+end_src
という変数を使って、粒子インデックスが ~N_A~ よりも小さかったらA粒子、大きかったらB粒子という寸法である。

さて、粒子配置が定まったら、2粒子をランダムに交換するのが第二ステップである。
これは、2成分LJモデルだから行っているステップであって、MDそのものとは関係がないことに注意されたい。
正方格子の位置に配置しただけだと、A粒子の領域とB粒子の領域が分離した状態からシミュレーションを開始することになる。
3次元系なら分離状態からでも均質な高温液体に緩和できるが、2次元系だとなかなか混ざらない。下図のように、分離したまま界面がグチャっとなるだけなのである。

[[./images/no_mix.png]]

そこで、このプログラムでは、各粒子の位置を適当にシャッフルして、シミュレーション開始前にA粒子とB粒子を混ぜておくことにする。
位置のシャッフルで対応しているのは、A粒子とB粒子の判定にグローバル変数 ~N_A~ を使っているからである。
粒子種の配列（例えば ~int species[N]~ ）を別途用意するなら、粒子種をシャッフルしてもよいだろう。
これを事前に行っておけば、均質な状態に持っていける。

[[./images/mix.png]]

第三のステップでは、速度を初期化する。ここでは、温度 $T = 1.0$ のマクスウェル・ボルツマン分布から、初期速度をランダムに生成している。
注意点が一つ。ランダムに速度を生成しただけだと系全体が速度を持つため、ドリフトが発生してしまう。
これは、構造緩和を追跡するときなどに不都合が生じるため、 ~remove_drift()~ という関数を書いて、ランダムな初期速度からドリフトを除いている。
この操作を行っても温度は変わらないことに注意。
なお、MDの練習では、初期速度はゼロで始めても構わない。

** 速度ベルレ法の実行
最後に、第四のステップとして、速度ベルレ法でシミュレーションを実行する。
基本的なループは ~NVE~ という関数の中を見れば分かると思う。
教科書で導出した通り、
1. 速度を更新： $v(t) = v(t) + \frac{\Delta t}{2} f(t)$
2. 位置を更新： $x(t) = x(t) + \Delta t v(t)$
3. 新しい位置で力を計算
4. 速度を更新： $v(t) = v(t) + \frac{\Delta t}{2} f(t)$
というループを回しているだけ。
位置を更新した所で、周期境界条件を適用してminimum-image conventionに戻しておくことをお忘れなく。

速度ベルレ法は、ニュートンの運動方程式を数値積分しているだけなので、エネルギー保存則が成り立つ。
そこで、対数時間間隔で
- 時刻
- 運動エネルギー
- ポテンシャルエネルギー
- 全エネルギー
を出力しておき（ ~print_energies~ ）、あとで確認のために使う。

** コンパイルと実行
さて、以上でプログラムの中身がだいたい理解できたと思うので、実際に実行してみよう。
付属する =CMakeLists.txt= を使うと、コンパイルは以下のようにできるだろう：
#+begin_src shell
mkdir build
cd build
cmake -DCMAKE_CXX_COMPILER=g++ ../
make
#+end_src
=CMAKE_CXX_COMPILER= を変えると、好みのコンパイラが使えると思う。

これで =a.out= が生成されるはずなので、実行する：
#+begin_src shell
./a.out > log.dat
#+end_src
前述の通り、実行するとエネルギーが標準出力されるので、 =log.dat= というファイルに保存することにした。
実行には少し時間がかかるはずである。
待ち切れない場合は、適当な所で =C-c= を押して強制終了して構わない。

** 結果の確認
得られたエネルギーの結果をグラフにしてみると、以下のようになる。

[[./images/results_potential.png]]

運動エネルギーとポテンシャルエネルギーは揺らいでいる一方、全エネルギーは保存していることが分かる。
だいたいの感覚として、生データを見たとき、運動エネルギーやポテンシャルエネルギーが変動する桁に比べて、全エネルギーが変動する桁が2、3桁小さければOKだと思う。
