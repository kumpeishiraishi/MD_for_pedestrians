* ベルレの隣接リスト
次に、基本的な高速化手法であるベルレの隣接リストを実装してみよう。

** 隣接リストの概要
前回のコードでは、力の計算 ~calc_force~ で粒子 $i$ と粒子 $j$ の二重ループを行っていた。
#+begin_src C++
for (int i=0; i<N; i++) {
    for (int j=i+1; j<N; j++) {
        // ij間の距離の計算
        // ...
        // ij間のカットオフ距離を計算
        // ...
        // 距離が近ければ相互作用を計算
        // if ...
    }
}
#+end_src
この二重ループは全粒子ペアに対して回っているので、計算量は $O(N^2)$ である。
しかし、今回は短距離相互作用の系を考えている。下図を見られたい。
着目する粒子 $i$ （図中赤丸）が実際に相互作用する粒子は、近傍の粒子（黒実線丸内、濃い緑色の粒子）に限られている。
従って力の計算 ~calc_force~ では、粒子 $j$ のループは粒子 $i$ の近傍の粒子に対してのみ回っていれば、本来は十分なはずだ。
粒子 $i$ の遠くに存在する粒子はそもそも相互作用しようがないのだから、上の二重ループ中で距離の計算をする必要がないという訳である。
Verletの隣接リストとは、各粒子に対して隣接粒子インデックスを事前に計算しておくことで、力の計算ループ中の無駄を省く高速化手法である。

[[./images/NL.png]]

ところで、1ステップ毎に粒子が移動する距離は $\Delta t$ の非常に小さいオーダーであるから、時間が数ステップ進んだところで、粒子 $i$ の近くにいる粒子の顔ぶれはあまり変わらない。
この事実を利用すると、一度構築した隣接リストはしばらく使い回すことができる。これが高速化に効いてくる。
隣接リストを使う旨みが分かったところで、実際の実装方法を見ていこう。

** 実装
隣接リストの実体としては、ペアとなる粒子のインデックスを保存する配列
#+begin_src C++
int list[N*100];
#+end_src
と、 ~list~ 中で粒子 $i$ のペア情報が開始される位置を示す
#+begin_src C++
int point[N];
#+end_src
を用いる。 ~list~ については余裕を見て、各粒子が100個のペア粒子を保存できるようにしている。

隣接リストを構築するには、上に示したような $O(N^2)$ の二重ループを用いればよい。
その際に、カットオフ距離内にいる粒子（上図の濃い緑色粒子）に加えて、適当な長さの ~margin~ の距離にいる粒子（上図の薄い緑色粒子）もペアと判定する。
これこそが隣接リストで高速化する肝である。
毎ステップ毎に隣接リストを構築していたら、いくら隣接リストを使って力を計算していても、計算量は変わらない。
適当なステップ数だけ隣接リストを使い回すことで、力の計算は $O(N)$ 、時折行う隣接リスト更新は $O(N^2)$ となり、全体で見て高速化できるのである。
~margin~ の長さの決め方については後述する。

** 隣接リストの利用方法
ここでは、構築した隣接リストを ~calc_force~ 中でどう使っているかを見てみよう。
元々の $O(N^)$ ループとの違いは、粒子 $j$ の内側ループが
#+begin_src C++
for (int p=point[i]; p<pend; p++) {
    // 粒子jのインデックスを取得
    const int j = list[p];

    // ij間の距離計算...
}
#+end_src
という形に変わっていることである。 ~pend~ は、次の粒子 $i+1$ の隣接粒子が始まる ~list~ でのインデックスである。
冒頭で説明した通り、粒子 $i$ の近傍に存在すると判定した粒子だけに対して $j$ のループを回しているのである。

** 隣接リストを更新する判断
一度構築した隣接リストは、「適当なステップ数」の間は使い回す。
粒子は時々刻々移動しているため、いつまでも古い隣接リストを使っていたら、正しい相互作用が計算できなくなってしまう。
隣接リストが有効な時間は、上で用いた ~margin~ が決定する。
~margin~ を越えて粒子間距離が変化してしまったら、もうその隣接リストは用を成さない。
これを判定するためには、隣接リスト構築時に、構築に使用した配置を保持しておく必要がある。そのために
#+begin_src C++
double NL_config[N][deg];
#+end_src
という配列を用いる。

~margin~ を越えたかの判定には、 ~NL_config~ からの各粒子の変位を毎ステップ毎に計算する。
粒子 $i = 0,\dots,N-1$ 中で最大の変位と2番目に最大の変位を計算しよう。
これらの和が ~margin~ を越えたとき、隣接リストはもはや正しい相互作用の計算に使えないと判断し、隣接リストを再度作り直す。

実際には、このような事態はほとんど起こらないことに注意しよう。
両者の和が ~margin~ を越える場合とは、最大変位の粒子と、2番目の粒子が同一線上に正反対の方向で運動していた場合であるが、そのような状況が稀なことはすぐ分かるであろう。
ここでは最も安全な方法として、この判断条件を採用している。

** マージンサイズの調整
上で見たように、一旦構築した隣接リストの「寿命」を決めるのは、 ~margin~ から飛び出した粒子がいるかどうかである。
どれくらいの ~margin~ を指定するのが最適かは、システムの詳細、実装、実行環境に依存するので、一概には言えない。
~margin~ を決めるのに行う常套手段としては、 ~margin~ をいくつかの値に変えながらシミュレーションの速さを比較してみる、というやり方である。
下のグラフは、横軸を ~margin~ の値、縦軸を $t=10^2$ のNVEシミュレーションを走らせるのに要した時間（ミリ秒）を表示したものである。
~margin~ が0.7くらいで時間が最も短くなっていることが分かるだろう。
今のシミュレーションでは、この辺りが最適値である。

[[./images/margin.png]]

~margin~ が小さすぎる場合（0.2とか）や大きすぎる場合（0.9とか）では、実行時間が増加してしまう。
前者の場合、 ~calc_force~ の最中に余計な計算は少ない（無駄な距離判定は少ない）けれども、隣接リストの再構築が頻繁に必要になり、全体のシミュレーションは遅くなる。
他方、後者の場合は、隣接リストの「寿命」は長い（再構築する機会は少ない）が、 ~calc_force~ の部分で余計な計算が多い（単純な $ij$ ループを回しているのと大差なくなる）から遅くなるのである。

繰り返すが、ちょうど良い塩梅の ~margin~ は、実行する環境やCPUや実装に応じて変化する。長い計算や大量の計算を流す前にチェックして最適値を見つけておくと、お財布にも環境にも優しいから是非やろう。

** 結果
隣接リストが正しく動いていることを確認するため、シミュレーションを実行した後の終配置を出力しよう。
#+begin_src shell
./a.out > new.dat
#+end_src
~std::mt19937~ のseedやシミュレーションの長さを揃えて、 $O(N^2)$ のコードでも終配置を出力しよう。
#+begin_src shell
./a.out > old.dat
#+end_src
両者を比較すると、
#+begin_src shell
diff old.dat new.dat
#+end_src
両者の配置は完全に一致することが分かる（コードを書くときは必ず確認！）。
つまり、隣接リストを使っても、全く同じシミュレーション軌道が得られたのである。

隣接リストによって得られたご利益を知るために、同じ長さのシミュレーションに要した時間を比較する。

[[./images/bar.png]]

結果を見ると、 $O(N^2)$ の単純なプログラムの半分以下の時間で計算が終了していることが分かる。
だいたい2.4倍ほどの高速化が達成された。
完全に同一の軌道を得ているのに、2倍以上もの差がつくのである。
最初の $O(N^2)$ ループには、不必要な距離計算が如何に多く含まれていたかが分かるだろう。

